"""
KFP Pipeline Compiler API
Provides endpoints for compiling Kubeflow pipeline definitions to YAML
"""
import logging
import tempfile
import os
import json
from typing import Any
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import sys

app = Flask(__name__)
CORS(app)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint"""
    return jsonify({'status': 'ok'})


@app.route('/api/compile', methods=['POST'])
def compile_pipeline():
    """
    Compile KFP Python code to YAML
    
    Request JSON:
    {
        "code": "Python pipeline code",
        "pipeline_name": "pipeline_name"
    }
    
    Response:
    {
        "success": true,
        "yaml": "compiled YAML content",
        "error": null
    }
    """
    try:
        data = request.json
        code = data.get('code', '')
        pipeline_name = data.get('pipeline_name', 'pipeline')

        if not code:
            return jsonify({
                'success': False,
                'error': 'No code provided'
            }), 400

        logger.info(f"Compiling pipeline: {pipeline_name}")

        # Create a temporary directory for the compilation
        with tempfile.TemporaryDirectory() as tmpdir:
            # Write the code to a temporary Python file
            temp_py_file = os.path.join(tmpdir, 'temp_pipeline.py')
            with open(temp_py_file, 'w') as f:
                f.write(code)
            
            logger.debug(f"Generated code:\n{code}")
            
            # Also save to a file for debugging
            debug_file = os.path.join(tmpdir, 'debug_generated.py')
            with open(debug_file, 'w') as f:
                f.write(code)

            # Change to the temp directory to avoid import issues
            original_cwd = os.getcwd()
            try:
                os.chdir(tmpdir)
                
                # Create output path for YAML
                yaml_path = os.path.join(tmpdir, f'{pipeline_name}.yaml')

                # Import the module using importlib to preserve source code
                import importlib.util
                spec = importlib.util.spec_from_file_location("temp_pipeline", temp_py_file)
                module = importlib.util.module_from_spec(spec)
                module.__file__ = temp_py_file
                sys.modules["temp_pipeline"] = module
                
                try:
                    # Verify code syntax before execution
                    import ast
                    try:
                        ast.parse(code)
                        logger.info("Code syntax is valid")
                    except SyntaxError as se:
                        logger.error(f"Syntax error in generated code: {se}")
                        return jsonify({
                            'success': False,
                            'error': f'Syntax error: {str(se)}'
                        }), 400
                    
                    # Execute the module - this should run if __name__ == "__main__" block
                    # But since we're using exec_module, __name__ will be the module name, not __main__
                    # So we need to check if the YAML was generated by the module load itself
                    spec.loader.exec_module(module)
                    logger.info(f"Module executed successfully")
                    
                except Exception as e:
                    logger.error(f"Error executing pipeline code: {str(e)}", exc_info=True)
                    return jsonify({
                        'success': False,
                        'error': f'Error executing code: {str(e)}'
                    }), 400

                # Check if YAML was generated
                if not os.path.exists(yaml_path):
                    logger.error(f"YAML file not generated at {yaml_path}")
                    logger.error(f"Current directory: {os.getcwd()}")
                    logger.error(f"Directory contents: {os.listdir('.')}")
                    return jsonify({
                        'success': False,
                        'error': 'YAML file not generated. Make sure code calls Compiler().compile(...)'
                    }), 400

                # Read the generated YAML
                with open(yaml_path, 'r') as f:
                    yaml_content = f.read()

                logger.info(f"Pipeline compiled successfully: {len(yaml_content)} bytes")

                return jsonify({
                    'success': True,
                    'yaml': yaml_content,
                    'error': None
                })
            finally:
                os.chdir(original_cwd)

    except json.JSONDecodeError:
        return jsonify({
            'success': False,
            'error': 'Invalid JSON'
        }), 400
    except Exception as e:
        logger.error(f"Unexpected error during compilation: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Server error: {str(e)}'
        }), 500


@app.route('/api/compile-yaml', methods=['POST'])
def compile_and_download():
    """
    Compile KFP Python code to YAML and return the file
    
    Request JSON:
    {
        "code": "Python pipeline code",
        "pipeline_name": "pipeline_name"
    }
    
    Response: YAML file download
    """
    try:
        data = request.json
        code = data.get('code', '')
        pipeline_name = data.get('pipeline_name', 'pipeline')

        if not code:
            return jsonify({
                'success': False,
                'error': 'No code provided'
            }), 400

        logger.info(f"Compiling and downloading pipeline: {pipeline_name}")

        # Create a temporary directory for the compilation
        with tempfile.TemporaryDirectory() as tmpdir:
            # Write the code to a temporary Python file
            temp_py_file = os.path.join(tmpdir, 'temp_pipeline.py')
            with open(temp_py_file, 'w') as f:
                f.write(code)

            # Change to temp directory to preserve context
            original_cwd = os.getcwd()
            try:
                os.chdir(tmpdir)
                
                # Create output path for YAML
                yaml_path = os.path.join(tmpdir, f'{pipeline_name}.yaml')

                # Import the module instead of using exec to allow KFP to find source
                import importlib.util
                spec = importlib.util.spec_from_file_location("temp_pipeline", temp_py_file)
                module = importlib.util.module_from_spec(spec)
                sys.modules["temp_pipeline"] = module
                
                try:
                    spec.loader.exec_module(module)
                except Exception as e:
                    logger.error(f"Error executing pipeline code: {str(e)}")
                    return jsonify({
                        'success': False,
                        'error': f'Error executing code: {str(e)}'
                    }), 400

                # Check if YAML was generated
                if not os.path.exists(yaml_path):
                    logger.error(f"YAML file not generated at {yaml_path}")
                    return jsonify({
                        'success': False,
                        'error': 'YAML file not generated'
                    }), 400

                # Send the file
                return send_file(
                    yaml_path,
                    as_attachment=True,
                    download_name=f'{pipeline_name}.yaml',
                    mimetype='application/x-yaml'
                )
            finally:
                os.chdir(original_cwd)

    except json.JSONDecodeError:
        return jsonify({
            'success': False,
            'error': 'Invalid JSON'
        }), 400
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Server error: {str(e)}'
        }), 500


@app.route('/api/validate', methods=['POST'])
def validate_code():
    """
    Validate Python code syntax
    
    Request JSON:
    {
        "code": "Python code to validate"
    }
    
    Response:
    {
        "valid": true,
        "errors": []
    }
    """
    try:
        data = request.json
        code = data.get('code', '')

        errors = []
        try:
            compile(code, '<string>', 'exec')
        except SyntaxError as e:
            errors.append({
                'line': e.lineno,
                'column': e.offset,
                'message': e.msg
            })
        except Exception as e:
            errors.append({
                'line': 0,
                'column': 0,
                'message': str(e)
            })

        return jsonify({
            'valid': len(errors) == 0,
            'errors': errors
        })

    except Exception as e:
        logger.error(f"Validation error: {str(e)}")
        return jsonify({
            'valid': False,
            'errors': [{'message': str(e)}]
        }), 500


if __name__ == '__main__':
    logger.info('Starting KFP Compiler API on port 5000...')
    app.run(host='0.0.0.0', port=5000, debug=False)
